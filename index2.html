<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>die-fraktur-der-frakturen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <!-- Hydra -->
  <script src="hydra-engine.js"></script>
  <!-- Tone.js -->
  <script src="tone-js-engine.txt"></script>
  <script src="//unpkg.com/brain.js"></script>
  <style>
    body {
      cursor: url('cursor.svg') 16 16, auto;
    }
    body.big-cursor {
      cursor: url('cursor-big.svg') 32 32, auto;
    }
  </style>
</head>
<body>
  <button id="startButton">Die Fraktur der Frakturen</button>
  <canvas id="myCanvas"></canvas>

  <script>
        const config1 = {
        binaryThresh: 0.5,
        // hiddenLayers: [16, 5, 7, 8], // array of ints for the sizes of the hidden layers in the network
        activation: 'sigmoid', // supported activation types: ['sigmoid', 'relu', 'leaky-relu', 'tanh'],
        leakyReluAlpha: 0.01, // supported for activation type 'leaky-relu'
        };

    // Helper: Generate random training data
    function generateTrainingData(numSamples, inputSize, outputSize, coeff) {
    const data = [];
    for (let i = 0; i < numSamples; i++) {
        const input = Array.from({ length: inputSize }, () => Math.random()*coeff);
        const output = Array.from({ length: outputSize }, () => Math.random()*coeff);
        data.push({ input, output });
    }
    return data;
    }

    // Create and train fft_net (32 inputs â†’ 8 outputs)
    const fft_net = new brain.NeuralNetwork(config1);
    const fftData = generateTrainingData(3, 32, 8, 1);
    fft_net.train(fftData, {
    iterations: 10,
    // log: true,
    // logPeriod: 200,
    });

    const startButton = document.getElementById("startButton");

    startButton.addEventListener("click", async () => {
      startButton.style.display = "none";

      // === Hydra visuals ===
      const hydra = new Hydra({
        canvas: document.getElementById("myCanvas"),
        detectAudio: true,
      });

      setResolution(window.innerWidth,window.innerHeight);
      await loadScript("lib-shader.js")
      
      s0 = 
        voronoi(10+Math.random()*5, ()=>mouse.x/width/200+0.5, ()=>mouse.y/height*-5)
        .modulate(o0,0.03+Math.random()*0.1)
        .mult(src(o0).modulateRotate(voronoi(20+Math.random()*5).color(1,2,3).r()),0.2+Math.random()*0.1)
        .modulateScrollX(src(o0).scrollX(()=>mouse.x/width/10),0.03+Math.random()*0.1)
        .thresh(0.5+Math.random()*0.1)
        .color(1,.9+Math.random()*0.01,.9+Math.random()*0.01)

      s1 = 
        voronoi(3+Math.random()*5, ()=>mouse.x/width/200+0.5, ()=>mouse.y/height*-5)
        .modulate(o0,0.03)
        .mult(src(o0).modulateRotate(voronoi(20+Math.random()).color(1,2,3).r()),0.2+Math.random()*0.01)
        .modulateScrollX(src(o0).scrollX(()=>mouse.x/width/10),0.03)
        .modulate(shape().repeat(20+Math.random()*5).modulateScrollX(noise(100)))
        .thresh(0.5+Math.random()*0.1)
        .color(1,.9+Math.random()*0.01,.85+Math.random()*0.1)
        .modulate(src(o0).repeat(()=>mouse.x/width/200+2),0.2)


      s1
        .blend(s0,()=>mouse.x/width*2)
        .mult(s2, ()=>mouse.y/height*2)
        .out();
      // s0 = warp();
      // s0.out();
      

      // === Tone.js FM Synth and GrainPlayer ===
      async function startSynthesis() {
        await Tone.start();
        
        const fft = new Tone.FFT(32); // 128 bins; you can increase to 512, 1024, etc.
        // Connect destination -> FFT
        Tone.Destination.connect(fft);

        // FX
        const pitchshift = new Tone.PitchShift();
        const reverb = new Tone.Reverb();
        const distortion = new Tone.Distortion(0.8);
        const feedbackDelay = new Tone.FeedbackDelay(0.001, 0.9);
        const crusher = new Tone.BitCrusher(4);

        // Synth1
        const fmOsc = new Tone.FMOscillator({
          frequency: 0,
          type: "sine",
          modulationType: "sine",
          harmonicity: 2,
          modulationIndex: 10,
          volume: -60
        }).connect(feedbackDelay);

        feedbackDelay.connect(pitchshift);
        pitchshift.connect(distortion);
        distortion.connect(reverb);
        crusher.connect(reverb);

        reverb.toDestination();

        //Synth_drone
        const fmOsc2 = new Tone.FMOscillator({
          frequency: 10,
          type: "triangle",
          modulationType: "triangle",
          harmonicity: 2.5,
          modulationIndex: 6,
          volume: -100
        }).connect(distortion);

        fmOsc.start();
        fmOsc2.start();


        // Variables for velocity calculation
        let lastX = null;
        let lastY = null;
        let lastTime = null;
        
        // Mouse move controls everything
        document.addEventListener("mousemove", (e) => {
          const xNorm = e.clientX / window.innerWidth;
          const yNorm = e.clientY / window.innerHeight;
          fmOsc.frequency.value =  xNorm * (25);
          fmOsc.modulationIndex.value = (1 - yNorm) * 30; 


          // Velocity calculation for FM synth volume
          const now = performance.now();
          if (lastX !== null && lastY !== null && lastTime !== null) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            const dt = (now - lastTime) / 1000;
            const velocity = Math.sqrt(dx * dx + dy * dy) / dt;
            const minVel = 0, maxVel = 2000;
            const minVol = -60, maxVol = -40;
            const mappedVol = Math.max(minVol, Math.min(maxVol,
              minVol + (maxVol - minVol) * (velocity - minVel) / (maxVel - minVel)
            ));
            fmOsc.volume.value = mappedVol;
          }
          lastX = e.clientX;
          lastY = e.clientY;
          lastTime = now;
        });

        setTimeout(() => {
            fmOsc2.volume.exponentialRampTo(-50, 2.5);
        },0);

        setInterval(() => {
            const newFreq = 10 + Math.random() * 2;
            const newModulation = 10 + Math.random() * 30;
            const newHarm = 1.5 + Math.random() * 1;

            fmOsc2.frequency.rampTo(newFreq, 10.0);
            fmOsc2.modulationIndex.rampTo(newModulation, 10.0);  
            fmOsc2.harmonicity.rampTo(newHarm, 10.0);           
        }, 10000);

        setInterval(() => {
            const newDelay = (Math.sin(performance.now()*2000)*Math.random()+1) * 0.0002;
            const newFeedback = Math.random()*0.1 + 0.9;
            var newHarm = fmOsc.harmonicity.value

            if (Math.random() >= 0.5){
                newHarm += Math.random()
            } else {newHarm -= Math.random()}
            
            feedbackDelay.delayTime.rampTo(newDelay, 0.1);  
            feedbackDelay.feedback.rampTo(newFeedback, 0.1);
            fmOsc.harmonicity.rampTo(newHarm, 0.1)  
        }, 100);

        //network update
        setInterval(() => {
            // console.log('mouse_net output:', mouse_net.run([mouse.x*100, mouse.y*100]));
            // console.log([mouse.x, mouse.y])
            console.log('fft_net output:', fft_net.run(fft.getValue()));
        }, 1000)
      }
      startSynthesis();
    });
  </script>
</body>
</html>
