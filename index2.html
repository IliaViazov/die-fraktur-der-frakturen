<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>die-fraktur-der-frakturen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <!-- Hydra -->
  <script src="hydra-engine.js"></script>
  <!-- Tone.js -->
  <script src="tone-js-engine.txt"></script>
  <script src="//unpkg.com/brain.js"></script>
  <style>
    body {
      cursor: url('cursor.svg') 16 16, auto;
    }
    body.big-cursor {
      cursor: url('cursor-big.svg') 32 32, auto;
    }
  </style>
</head>
<body>
  <button id="startButton">Die Fraktur der Frakturen</button>
  <canvas id="myCanvas"></canvas>

  <script>
    // provide optional config object (or undefined). Defaults shown.
    const config = {
    binaryThresh: 0.5,
    hiddenLayers: [3], // array of ints for the sizes of the hidden layers in the network
    activation: 'sigmoid', // supported activation types: ['sigmoid', 'relu', 'leaky-relu', 'tanh'],
    leakyReluAlpha: 0.01, // supported for activation type 'leaky-relu'
    };

// create a simple feed-forward neural network with backpropagation
    const net = new brain.NeuralNetwork(config);

    net.train([
    { input: [0, 0], output: [0] },
    { input: [0, 1], output: [1] },
    { input: [1, 0], output: [1] },
    { input: [1, 1], output: [0] },
    ]);

    console.log(net.run([1, 0])); // [0.987]




    //======Old code

    const startButton = document.getElementById("startButton");

    startButton.addEventListener("click", async () => {
      startButton.style.display = "none";

      // === Hydra visuals ===
      const hydra = new Hydra({
        canvas: document.getElementById("myCanvas"),
        detectAudio: true,
      });

    //   mainCanvas = document.createElement('canvas');
    //   ctx = myCanvas.getContext('2d');
    //   ctx.font = "20px Arial"
    //   ctx.fillStyle = "red";
    //   ctx.fillText("fraktur", 100, 50, 500);

    //   s0.init({ src: mainCanvas, dynamic: true, setResolution:"200x200" });
      setResolution(window.innerWidth,window.innerHeight);
      
      await loadScript("lib-shader.js")
      
      s0 = 
        voronoi(10+Math.random()*5, ()=>mouse.x/width/200+0.5, ()=>mouse.y/height*-5)
        .modulate(o0,0.03+Math.random()*0.1)
        .mult(src(o0).modulateRotate(voronoi(20+Math.random()*5).color(1,2,3).r()),0.2+Math.random()*0.1)
        .modulateScrollX(src(o0).scrollX(()=>mouse.x/width/10),0.03+Math.random()*0.1)
        .thresh(0.5+Math.random()*0.1)
        .color(1,.9+Math.random()*0.01,.9+Math.random()*0.01)

      s1 = 
        voronoi(3+Math.random()*5, ()=>mouse.x/width/200+0.5, ()=>mouse.y/height*-5)
        .modulate(o0,0.03)
        .mult(src(o0).modulateRotate(voronoi(20+Math.random()).color(1,2,3).r()),0.2+Math.random()*0.01)
        .modulateScrollX(src(o0).scrollX(()=>mouse.x/width/10),0.03)
        .modulate(shape().repeat(20+Math.random()*5).modulateScrollX(noise(100)))
        .thresh(0.5+Math.random()*0.1)
        .color(1,.9+Math.random()*0.01,.85+Math.random()*0.1)
        .modulate(src(o0).repeat(()=>mouse.x/width/200+2),0.2)


      s1
        .blend(s0,()=>mouse.x/width*2)
        .mult(s2, ()=>mouse.y/height*2)
        .out();
      // s0 = warp();
      // s0.out();
      

      // === Tone.js FM Synth and GrainPlayer ===
      async function startSynthesis() {
        await Tone.start();
        
        function ffr(destination) {
        // Create an FFT analyzer
            const fft = new Tone.FFT(32); // 128 bins; you can increase to 512, 1024, etc.
    
            // Connect destination -> FFT
            destination.connect(fft);

            // Function to update and print data
            function update() {
                const values = fft.getValue(); // returns Float32Array of amplitudes in dB
                console.log(Array.from(values)); // print as plain list
                requestAnimationFrame(update);   // keep reading continuously
            }
            update();
            return fft;
        }
        // FX
        const pitchshift = new Tone.PitchShift();
        const reverb = new Tone.Reverb();
        const distortion = new Tone.Distortion(0.8);
        const feedbackDelay = new Tone.FeedbackDelay(0.001, 0.9);
        const crusher = new Tone.BitCrusher(4);

        // Synth1
        const fmOsc = new Tone.FMOscillator({
          frequency: 0,
          type: "sine",
          modulationType: "sine",
          harmonicity: 2,
          modulationIndex: 10,
          volume: -60
        }).connect(feedbackDelay);

        feedbackDelay.connect(pitchshift);
        pitchshift.connect(distortion);
        distortion.connect(reverb);
        crusher.connect(reverb);

        reverb.toDestination();

        //Synth_drone
        const fmOsc2 = new Tone.FMOscillator({
          frequency: 10,
          type: "triangle",
          modulationType: "triangle",
          harmonicity: 2.5,
          modulationIndex: 6,
          volume: -100
        }).connect(distortion);

        fmOsc.start();
        fmOsc2.start();


        // Variables for velocity calculation
        let lastX = null;
        let lastY = null;
        let lastTime = null;
        
        // Mouse move controls everything
        document.addEventListener("mousemove", (e) => {
          const xNorm = e.clientX / window.innerWidth;
          const yNorm = e.clientY / window.innerHeight;
          fmOsc.frequency.value =  xNorm * (25);
          fmOsc.modulationIndex.value = (1 - yNorm) * 30; 


          // Velocity calculation for FM synth volume
          const now = performance.now();
          if (lastX !== null && lastY !== null && lastTime !== null) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            const dt = (now - lastTime) / 1000;
            const velocity = Math.sqrt(dx * dx + dy * dy) / dt;
            const minVel = 0, maxVel = 2000;
            const minVol = -60, maxVol = -40;
            const mappedVol = Math.max(minVol, Math.min(maxVol,
              minVol + (maxVol - minVol) * (velocity - minVel) / (maxVel - minVel)
            ));
            fmOsc.volume.value = mappedVol;
          }
          lastX = e.clientX;
          lastY = e.clientY;
          lastTime = now;
        });

        setTimeout(() => {
            fmOsc2.volume.exponentialRampTo(-50, 2.5);
        },0);

        setInterval(() => {
            const newFreq = 10 + Math.random() * 2;
            const newModulation = 10 + Math.random() * 30;
            const newHarm = 1.5 + Math.random() * 1;

            fmOsc2.frequency.rampTo(newFreq, 10.0);
            fmOsc2.modulationIndex.rampTo(newModulation, 10.0);  
            fmOsc2.harmonicity.rampTo(newHarm, 10.0);           
        }, 10000);

        setInterval(() => {
            const newDelay = (Math.sin(performance.now()*2000)*Math.random()+1) * 0.0002;
            const newFeedback = Math.random()*0.1 + 0.9;
            var newHarm = fmOsc.harmonicity.value

            if (Math.random() >= 0.5){
                newHarm += Math.random()
            } else {newHarm -= Math.random()}
            
            feedbackDelay.delayTime.rampTo(newDelay, 0.1);  
            feedbackDelay.feedback.rampTo(newFeedback, 0.1);
            fmOsc.harmonicity.rampTo(newHarm, 0.1)  
        }, 100);

        // console.log(ffr(Tone.Destination));
      }
      startSynthesis();
    });
  </script>
</body>
</html>
